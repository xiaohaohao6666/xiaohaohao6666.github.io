(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{169:function(a,t,r){"use strict";r.r(t);var s=r(0),h=Object(s.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"this"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[a._v("#")]),a._v(" this")]),a._v(" "),r("h2",{attrs:{id:"判断this"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断this","aria-hidden":"true"}},[a._v("#")]),a._v(" 判断this")]),a._v(" "),r("h2",{attrs:{id:"现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：","aria-hidden":"true"}},[a._v("#")]),a._v(" 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：")]),a._v(" "),r("h2",{attrs:{id:"_1-函数是否在-new-中调用（new-绑定）？如果是的话-this-绑定的是新创建的对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-函数是否在-new-中调用（new-绑定）？如果是的话-this-绑定的是新创建的对象。","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。")]),a._v(" "),r("h2",{attrs:{id:"var-bar-new-foo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-bar-new-foo","aria-hidden":"true"}},[a._v("#")]),a._v(" var bar = new foo()")]),a._v(" "),r("h2",{attrs:{id:"_2-函数是否通过-call、apply（显式绑定）或者硬绑定调用？如果是的话，this-绑定的是指定的对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数是否通过-call、apply（显式绑定）或者硬绑定调用？如果是的话，this-绑定的是指定的对象。","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。")]),a._v(" "),r("h2",{attrs:{id:"var-bar-foo-call-obj2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-bar-foo-call-obj2","aria-hidden":"true"}},[a._v("#")]),a._v(" var bar = foo.call(obj2)")]),a._v(" "),r("h2",{attrs:{id:"_3-函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this-绑定的是那个上下文对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this-绑定的是那个上下文对象。","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。")]),a._v(" "),r("h2",{attrs:{id:"var-bar-obj1-foo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-bar-obj1-foo","aria-hidden":"true"}},[a._v("#")]),a._v(" var bar = obj1.foo()")]),a._v(" "),r("h2",{attrs:{id:"_4-如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到-undefined，否则绑定到全局对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到-undefined，否则绑定到全局对象。","aria-hidden":"true"}},[a._v("#")]),a._v(" 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。")]),a._v(" "),r("h2",{attrs:{id:"var-bar-foo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-bar-foo","aria-hidden":"true"}},[a._v("#")]),a._v(" var bar = foo()")]),a._v(" "),r("h2",{attrs:{id:"就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白-this-的绑定原理了。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白-this-的绑定原理了。","aria-hidden":"true"}},[a._v("#")]),a._v(" 就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。")]),a._v(" "),r("h2",{attrs:{id:"如果你经常编写-this-风格的代码，但是绝大部分时候都会使用-self-this-或者箭头函数来否定-this-机制，那你或许应当："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果你经常编写-this-风格的代码，但是绝大部分时候都会使用-self-this-或者箭头函数来否定-this-机制，那你或许应当：","aria-hidden":"true"}},[a._v("#")]),a._v(" 如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数来否定 this 机制，那你或许应当：")]),a._v(" "),r("h2",{attrs:{id:"_1-只使用词法作用域并完全抛弃错误-this-风格的代码；"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-只使用词法作用域并完全抛弃错误-this-风格的代码；","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 只使用词法作用域并完全抛弃错误 this 风格的代码；")]),a._v(" "),r("h2",{attrs:{id:"_2-完全采用-this-风格，在必要时使用-bind-，尽量避免使用-self-this-和箭头函数。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-完全采用-this-风格，在必要时使用-bind-，尽量避免使用-self-this-和箭头函数。","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。")]),a._v(" "),r("h2",{attrs:{id:"当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。","aria-hidden":"true"}},[a._v("#")]),a._v(" 当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。")])])},[],!1,null,null,null);t.default=h.exports}}]);