<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 数据结构（2-2）：栈与队列-队列篇 | Evan-Blog</title>
    <meta name="description" content="与其纠结无法改变的过去,不如微笑的面对未来，因为生活，没有如果">
    <link rel="icon" href="/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.919eb087.css" as="style"><link rel="preload" href="/assets/js/app.0bd50222.js" as="script"><link rel="preload" href="/assets/js/2.6fd8f351.js" as="script"><link rel="preload" href="/assets/js/35.905b0317.js" as="script"><link rel="prefetch" href="/assets/js/10.5e392867.js"><link rel="prefetch" href="/assets/js/11.84f1836c.js"><link rel="prefetch" href="/assets/js/12.8f316b4a.js"><link rel="prefetch" href="/assets/js/13.14475169.js"><link rel="prefetch" href="/assets/js/14.ded4b88e.js"><link rel="prefetch" href="/assets/js/15.0b995197.js"><link rel="prefetch" href="/assets/js/16.116588f7.js"><link rel="prefetch" href="/assets/js/17.5b816f87.js"><link rel="prefetch" href="/assets/js/18.d1ef4c96.js"><link rel="prefetch" href="/assets/js/19.6d944fe8.js"><link rel="prefetch" href="/assets/js/20.9d512630.js"><link rel="prefetch" href="/assets/js/21.8fdec6e1.js"><link rel="prefetch" href="/assets/js/22.2cb5666e.js"><link rel="prefetch" href="/assets/js/23.dfc1334c.js"><link rel="prefetch" href="/assets/js/24.4b5c23c2.js"><link rel="prefetch" href="/assets/js/25.350f5bde.js"><link rel="prefetch" href="/assets/js/26.1b8b511f.js"><link rel="prefetch" href="/assets/js/27.eca3f782.js"><link rel="prefetch" href="/assets/js/28.151f30c6.js"><link rel="prefetch" href="/assets/js/29.381db2e3.js"><link rel="prefetch" href="/assets/js/3.61ea6075.js"><link rel="prefetch" href="/assets/js/30.ded9e5f7.js"><link rel="prefetch" href="/assets/js/31.f1ea7050.js"><link rel="prefetch" href="/assets/js/32.28eb4a8a.js"><link rel="prefetch" href="/assets/js/33.4a3190e3.js"><link rel="prefetch" href="/assets/js/34.5883e361.js"><link rel="prefetch" href="/assets/js/36.ae5f3b67.js"><link rel="prefetch" href="/assets/js/37.9a212de8.js"><link rel="prefetch" href="/assets/js/38.f54db468.js"><link rel="prefetch" href="/assets/js/39.673f6aed.js"><link rel="prefetch" href="/assets/js/4.47b1dc0d.js"><link rel="prefetch" href="/assets/js/40.0d86b015.js"><link rel="prefetch" href="/assets/js/41.2b6fb392.js"><link rel="prefetch" href="/assets/js/42.aab801fd.js"><link rel="prefetch" href="/assets/js/43.05891ba6.js"><link rel="prefetch" href="/assets/js/44.5eda5d3e.js"><link rel="prefetch" href="/assets/js/45.d36197be.js"><link rel="prefetch" href="/assets/js/5.a5e71125.js"><link rel="prefetch" href="/assets/js/6.6b062761.js"><link rel="prefetch" href="/assets/js/7.15eb1c76.js"><link rel="prefetch" href="/assets/js/8.1d568626.js"><link rel="prefetch" href="/assets/js/9.1a8c218a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.919eb087.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Evan-Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端之路</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/web/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/web/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/life/" class="nav-link">平凡之路</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/xiaohaohao6666" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端之路</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/web/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/web/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/life/" class="nav-link">平凡之路</a></div><div class="nav-item"><a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  VuePress
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/xiaohaohao6666" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript面试题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript面向对象编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript数据结构</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web/jsDataStructures/" class="sidebar-link">JavaScript 数据结构（1）：什么是数据结构？</a></li><li><a href="/web/jsDataStructures/one.html" class="sidebar-link">JavaScript 数据结构（2-1）：栈与队列-栈篇</a></li><li><a href="/web/jsDataStructures/two.html" class="active sidebar-link">JavaScript 数据结构（2-2）：栈与队列-队列篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#从栈到队列" class="sidebar-link">从栈到队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#队列" class="sidebar-link">队列</a></li><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#队列的实现" class="sidebar-link">队列的实现</a></li><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#队列的完整实现代码" class="sidebar-link">队列的完整实现代码</a></li><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#结束语" class="sidebar-link">结束语</a></li><li class="sidebar-sub-header"><a href="/web/jsDataStructures/two.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></li><li><a href="/web/jsDataStructures/three.html" class="sidebar-link">JavaScript数据结构(3-1)：单向链表与双向链表——单向链表篇</a></li><li><a href="/web/jsDataStructures/four.html" class="sidebar-link">JavaScript数据结构(3-2)：单向链表与双向链表——双向链表篇</a></li><li><a href="/web/jsDataStructures/five.html" class="sidebar-link">JavaScript数据结构（4）：树</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript数据结构与算法之美</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>V8 引擎解析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue-cli3.0使用教程</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-数据结构（2-2）：栈与队列-队列篇"><a href="#javascript-数据结构（2-2）：栈与队列-队列篇" aria-hidden="true" class="header-anchor">#</a> JavaScript 数据结构（2-2）：栈与队列-队列篇</h1> <h2 id="从栈到队列"><a href="#从栈到队列" aria-hidden="true" class="header-anchor">#</a> 从栈到队列</h2> <p>当我们想要按顺序添加数据或删除数据时，可以使用栈结构。根据它的定义，栈可以只删除最近添加的数据。如果想要删除最早的数据该怎么办呢?这时我们希望使用名为queue的数据结构。</p> <h3 id="队列"><a href="#队列" aria-hidden="true" class="header-anchor">#</a> 队列</h3> <p>与栈类似，队列也是一个线性数据结构。与栈不同的是，队列只删除最先添加的数据。
为了帮助你明白队列这是如何工作的，让我们花点时间举个例子。我们可以把队列想象成为熟食店的售票系统。每个顾客拿一张票，当他们的号码被呼叫时送达。持第一张票的顾客首先接受服务。
再进一步想象一下，这张票上有一个数字“1”。下一张票上有数字“2”。得到二张票的顾客将会第二个接受服务。（如果我们的售票系统像栈一样运行，最先进入堆栈的客户将会最后一个接受服务！）
队列的一个更实际的例子是Web浏览器的事件循环。当触发不同事件时，例如单击某个按钮，点击事件将被添加到事件循环队列中，并按照它们进入队列的顺序进行处理。
现在我们有了队列的概念模型，接下来就定义它的操作。你会注意到，队列的操作和栈非常相似。区别就在被删除的数据在什么地方。</p> <p>1.enqueue(data) 将数据添加到队列中。</p> <p>2.dequeue 删除最早加入队列的数据。</p> <h3 id="队列的实现"><a href="#队列的实现" aria-hidden="true" class="header-anchor">#</a> 队列的实现</h3> <p>现在让我们开始写队列的代码吧！</p> <h4 id="队列的属性"><a href="#队列的属性" aria-hidden="true" class="header-anchor">#</a> 队列的属性</h4> <p>在实现队列的代码中，我们将会创建一个名为 Queue 的构造方法。接下来添加三个属性：_oldestIndex, _newestIndex, 和 _storage。在下一小节中，_oldestIndex 和 _newestIndex 的作用将变得更加清晰。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_storage <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="队列的方法"><a href="#队列的方法" aria-hidden="true" class="header-anchor">#</a> 队列的方法</h4> <p>现在我们将创建队列会用到的三个方法：size(), enqueue(data), 和 dequeue(data)。我将描述每个方法的作用，写出每个方法的代码，然后解释这些代码。</p> <h4 id="方法1-3：size"><a href="#方法1-3：size" aria-hidden="true" class="header-anchor">#</a> 方法1/3：size( )</h4> <div class="tip custom-block"><p class="custom-block-title">这个方法有两个作用：</p> <p>1.返回当前队列的长度。</p> <p>2.保持队列中键的正确范围。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">size</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>实现 size() 可能显得微不足道，但你会很快发现并不是这样的。为了理解其原因，我们必须快速重新审视 size() 在栈结构中的实现。</p> <p>回想一下栈的概念模型，假设我们把5个盘子添加到一个栈上。我们的栈的大小是5，每个盘子都有一个数字，从1(第一个添加的盘子)到5(最后一个添加的盘子)。</p> <p>如果我们取走三个盘子，就只剩下两个盘子。我们可以简单地用5减去3，得到正确的大小，也就是2。</p> <p>这里是关于栈大小最重要的一点：当前大小相当于从栈顶部的盘子（2）到栈中其他盘子（1）的计数。换句话说，键的范围总是从当前大小到1之间。</p> <p>现在，让我们将栈大小的实现应用到队列中。假设有五个顾客从我们的售票系统中取到了票。</p> <p>第一个顾客有一张显示数字1的票，第五个客户有一张显示数字5的票。现在有了一个队列，拿着第一张票的第一位顾客。</p> <p>假设第一个客户接受了服务，这张票会从队列中被移除。与栈类似，我们可以通过从5减去1来获得队列的正确大小。那么服务队列中还有4张票。</p> <p>现在出现了一个问题：队列的大小不能对应正确的票号。如果我们从五减去一个，得到大小是4，但是不能使用4来确定当前队列中剩余票的编号范围。我们并不能确定队列中票号的顺序到底是1到4还是2到5。</p> <p>这就是 oldestIndex 和 newestIndex 这两个属性 在队列中的用途。所有这一切似乎令人困惑——到现在我仍然会偶尔觉得困惑。下面的例子可以帮助我门理顺所有的逻辑。</p> <p>假设我们的熟食店有两个售票系统：</p> <p>1._newestindex 代表顾客售票系统的票。</p> <p>2._oldestindex 代表员工售票系统的票。</p> <p>对于两个售票系统来说，这是最难掌握的概念：当两个系统中的数字相同时，队列中的每个客户都被处理了，队列是空的。</p> <p>我们将使用下面的场景来加强这种逻辑：</p> <p>1.当顾客买票时，顾客的票号从_newestIndex 得到，票的编号是1。顾客售票系统的下一张票号码是2。</p> <p>2.员工不买票，员工售票系统中当前票的编号是1。</p> <p>3.我们在顾客系统中得到当前的票号2，减去员工系统中的号码1，得到的结果是1。这个数字1表示仍然在队列中没有被删除的票的数量</p> <p>4.员工从它们的售票系统中取票，这张票代表正在被服务的顾客的票号，从_oldestIndex中得到，数字为1。</p> <p>5.重复第4步，现在差为0，队列中没有其他的票了。</p> <p>现在属性 _newestindex可以告诉我们被分配在队列中票号的最大值（键），属性 _oldestindex 可以告诉我们最先进入队列中票号（键）。
探讨完了size()，接下来看enqueue(data)方法。</p> <h4 id="方法2-3：enqueue-data"><a href="#方法2-3：enqueue-data" aria-hidden="true" class="header-anchor">#</a> 方法2/3：enqueue(data)</h4> <div class="tip custom-block"><p class="custom-block-title">对于 enqueue 方法，有两个功能：</p> <p>1.使用_newestIndex 的值作为 this._storage 的键，并使用要添加的数据作为该键的值。</p> <p>2.将_newestIndex 的值增加1。基于这两个功能，我们将编写 enqueue(data) 方法的代码：</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">enqueue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>该方法的主体只有两行代码。 在第一行，用 this._newestIndex 为this._storage 创建一个新的键，并为其分配数据。 this._newestIndex 始终从1开始。在第二行代码中，我们将 this._newestIndex 的值增加1，将其更新为2。
以上是方法 enqueue(data) 的所有代码。下面我们来实现方法 dequeue( )。</p> <h4 id="方法3-3：dequeue"><a href="#方法3-3：dequeue" aria-hidden="true" class="header-anchor">#</a> 方法3/3：dequeue( )</h4> <div class="tip custom-block"><p class="custom-block-title">以下是此方法的两个功能点：</p> <p>1.删除队列中最旧的数据。</p> <p>2.属性 _oldestIndex 加1。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">dequeue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> oldestIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token punctuation">,</span>
        deletedData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> deletedData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在 dequeue( )的代码中，我们声明两个变量。</p> <p>第一个变量 oldestIndex 给 this._oldestIndex 赋值。</p> <p>第二个变量 deletedData 被赋予 this._storage[oldestIndex] 的值。</p> <p>下一步，删除队列中最早的索引。之后将 this._oldestIndex 的值加1。最后返回刚刚被删除的数据。</p> <p>与栈的 pop() 方法第一次实现中出现的问题类似，dequeue() 在队列中没有数据的情况下不应该被执行。</p> <p>我们需要一些代码来处理这种情况。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">dequeue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> oldestIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token punctuation">,</span>
        newestIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token punctuation">,</span>
        deletedData<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldestIndex <span class="token operator">!==</span> newestIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        deletedData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> deletedData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>每当 oldestIndex 和 newestIndex 的值不相等时，我们就执行前面的逻辑。</p> <h3 id="队列的完整实现代码"><a href="#队列的完整实现代码" aria-hidden="true" class="header-anchor">#</a> 队列的完整实现代码</h3> <p>到此为止，我们实现了一个完整的队列结构的逻辑。下面是全部代码。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_storage <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">size</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">enqueue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Queue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">dequeue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> oldestIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token punctuation">,</span>
        newestIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_newestIndex<span class="token punctuation">,</span>
        deletedData<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldestIndex <span class="token operator">!==</span> newestIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        deletedData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_storage<span class="token punctuation">[</span>oldestIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_oldestIndex<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> deletedData<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="结束语"><a href="#结束语" aria-hidden="true" class="header-anchor">#</a> 结束语</h3> <p>在本文中，我们探讨了两个线性数据结构：栈和队列。栈按照顺序存储数据，并删除最后添加的数据；队列按顺序存储数据，但删除最先的添加数据。
如果这些数据结构的实现看起来微不足道，请提醒自己数据结构的用途。它们并没有被设计得过于复杂，它们是用来帮助我们组织数据的。在这种情况下，如果您发现有需要按顺序组织数据的场合，请考虑使用栈或队列。</p> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>第二篇文章用生活中的例子为大家讲解了栈和队列的原理和实现细节，在这里我还要BB两句：</p> <ol><li><p>栈的性质是后进先出，英文是 LIFO (Last In First Out)。</p></li> <li><p>队列的性质是先进先出，FIFO (First In First Out)。</p></li></ol> <p>嗯，英语还是很有用的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/web/jsDataStructures/one.html" class="prev">
          JavaScript 数据结构（2-1）：栈与队列-栈篇
        </a></span> <span class="next"><a href="/web/jsDataStructures/three.html">
          JavaScript数据结构(3-1)：单向链表与双向链表——单向链表篇
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.0bd50222.js" defer></script><script src="/assets/js/2.6fd8f351.js" defer></script><script src="/assets/js/35.905b0317.js" defer></script>
  </body>
</html>
